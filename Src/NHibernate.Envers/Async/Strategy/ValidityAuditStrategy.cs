//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml.Linq;
using NHibernate.Engine;
using NHibernate.Envers.Configuration;
using NHibernate.Envers.Configuration.Metadata;
using NHibernate.Envers.Entities.Mapper;
using NHibernate.Envers.Entities.Mapper.Relation;
using NHibernate.Envers.Entities.Mapper.Relation.Query;
using NHibernate.Envers.Synchronization;
using NHibernate.Envers.Tools.Query;
using NHibernate.Type;

namespace NHibernate.Envers.Strategy
{
	using System.Threading.Tasks;
	using System.Threading;
	public partial class ValidityAuditStrategy : IAuditStrategy
	{

		public async Task PerformAsync(ISession session, string entityName, object id, object data, object revision, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			var auditedEntityName = _auditConfiguration.AuditEntCfg.GetAuditEntityName(entityName);

			var reuseEntityIdentifier = _auditConfiguration.GlobalCfg.AllowIdentifierReuse;
			// Update the end date of the previous row if this operation is expected to have a previous row
			var revisionTypeIsAdded = revisionType(_auditConfiguration, data) == RevisionType.Added;
			if (reuseEntityIdentifier || !revisionTypeIsAdded)
			{
				/*
				 Constructing a query:
				 select e from audited_ent e where e.end_rev is null and e.id = :id
				*/
				var qb = new QueryBuilder(auditedEntityName, QueryConstants.MiddleEntityAlias);

				// e.id = :id
				var idMapper = _auditConfiguration.EntCfg[entityName].IdMapper;
				idMapper.AddIdEqualsToQuery(qb.RootParameters, id, _auditConfiguration.AuditEntCfg.OriginalIdPropName, true);

				addEndRevisionNullRestriction(_auditConfiguration, qb);

				var l = await (qb.ToQuery(session).SetLockMode(QueryConstants.MiddleEntityAlias, LockMode.Upgrade).ListAsync(cancellationToken)).ConfigureAwait(false);

				await (updateLastRevisionAsync(session, _auditConfiguration, l, id, auditedEntityName, revision, (!reuseEntityIdentifier || !revisionTypeIsAdded), cancellationToken)).ConfigureAwait(false);
			}

			// Save the audit data
			await (session.SaveAsync(auditedEntityName, data, cancellationToken)).ConfigureAwait(false);
			SessionCacheCleaner.ScheduleAuditDataRemoval(session, data);
		}

		public async Task PerformCollectionChangeAsync(ISession session, string entityName, string propertyName, AuditConfiguration auditCfg, PersistentCollectionChangeData persistentCollectionChangeData, object revision, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			var qb = new QueryBuilder(persistentCollectionChangeData.EntityName, QueryConstants.MiddleEntityAlias);

			var originalIdPropName = _auditConfiguration.AuditEntCfg.OriginalIdPropName;
			var originalId = (IDictionary)persistentCollectionChangeData.Data[originalIdPropName];
			var revisionFieldName = auditCfg.AuditEntCfg.RevisionFieldName;
			var revisionTypePropName = auditCfg.AuditEntCfg.RevisionTypePropName;

			// Adding a parameter for each id component, except the rev number and type.
			foreach (DictionaryEntry originalIdKeyValue in originalId)
			{
				if (!revisionFieldName.Equals(originalIdKeyValue.Key) && !revisionTypePropName.Equals(originalIdKeyValue.Key))
				{
					qb.RootParameters.AddWhereWithParam(originalIdPropName + "." + originalIdKeyValue.Key, true, "=", originalIdKeyValue.Value);
				}
			}

			var sessionFactory = ((ISessionImplementor)session).Factory;
			var propertyType = sessionFactory.GetEntityPersister(entityName).GetPropertyType(propertyName);
			if (propertyType.IsCollectionType)
			{
				var collectionPropertyType = (CollectionType)propertyType;
				// Handling collection of components.
				if (collectionPropertyType.GetElementType(sessionFactory) is ComponentType)
				{
					// Adding restrictions to compare data outside of primary key.
					// todo: is it necessary that non-primary key attributes be compared?
					foreach (var dataEntry in persistentCollectionChangeData.Data)
					{
						if (!originalIdPropName.Equals(dataEntry.Key))
						{
							if (dataEntry.Value != null)
							{
								qb.RootParameters.AddWhereWithParam(dataEntry.Key, true, "=", dataEntry.Value);
							}
							else
							{
								qb.RootParameters.AddNullRestriction(dataEntry.Key, true);
							}
						}
					}
				}
			}

			addEndRevisionNullRestriction(_auditConfiguration, qb);

			var l = await (qb.ToQuery(session).SetLockMode(QueryConstants.MiddleEntityAlias, LockMode.Upgrade).ListAsync(cancellationToken)).ConfigureAwait(false);

			if (l.Count > 0)
			{
				await (updateLastRevisionAsync(session, _auditConfiguration, l, originalId, persistentCollectionChangeData.EntityName, revision, true, cancellationToken)).ConfigureAwait(false);
			}

			// Save the audit data
			var data = persistentCollectionChangeData.Data;
			await (session.SaveAsync(persistentCollectionChangeData.EntityName, data, cancellationToken)).ConfigureAwait(false);
			SessionCacheCleaner.ScheduleAuditDataRemoval(session, data);
		}

		private async Task updateLastRevisionAsync(ISession session, AuditConfiguration auditCfg, IList l,
									object id, string auditedEntityName, object revision, bool throwIfNotOneEntry, CancellationToken cancellationToken = default(CancellationToken))
		{
			cancellationToken.ThrowIfCancellationRequested();
			// There should be one entry
			if (l.Count == 1)
			{
				// Setting the end revision to be the current rev
				var previousData = (IDictionary) l[0];
				var revisionEndFieldName = auditCfg.AuditEntCfg.RevisionEndFieldName;
				previousData[revisionEndFieldName] = revision;

				if (auditCfg.AuditEntCfg.IsRevisionEndTimestampEnabled)
				{
					// Determine the value of the revision property annotated with @RevisionTimestamp
					DateTime revisionEndTimestamp;
					var revEndTimestampFieldName = auditCfg.AuditEntCfg.RevisionEndTimestampFieldName;
					var revEndTimestampObj = _auditConfiguration.RevisionTimestampGetter.Get(revision);

					// convert to a DateTime
					if (revEndTimestampObj is DateTime)
					{
						revisionEndTimestamp = (DateTime) revEndTimestampObj;
					}
					else
					{
						revisionEndTimestamp = new DateTime((long) revEndTimestampObj);
					}

					// Setting the end revision timestamp
					previousData[revEndTimestampFieldName] = revisionEndTimestamp;
				}

				// Saving the previous version
				await (session.SaveAsync(auditedEntityName, previousData, cancellationToken)).ConfigureAwait(false);
				SessionCacheCleaner.ScheduleAuditDataRemoval(session, previousData);
			}
			else
			{
				if (throwIfNotOneEntry)
				{
					throw new InvalidOperationException("Cannot find previous revision for entity " + auditedEntityName + " and id " + id);					
				}
			}
		}
	}
}